#!/usr/bin/env bash

set -u

doUpdate="yes"
doCount="yes"
OPTIND=1
while getopts dC opt; do case $opt in
    d) doDebug="yes"    ;;
    C) doUpdate=""      ;;
    *) >&2 echo "Unsupported option '$opt', ignoring"
esac; done; shift $((OPTIND - 1))

manifest="${1:-""}"

# I should define these at the shell level
stdErr () {
    printf >&2 "%s\n" "${@}"
}
debug () {
    [[ ${doDebug:+IS_SET} && $# -gt 0 ]] && stdErr "${@}"
    true
}

## these next two are cool, I am keeping them for posterity,
## even if I am not using them anymore....
#resetVariableIfComment () {
#    [[ $# -ne 1 ]] && return
#    local -n variable=$1
#    fC="${variable:0:1}"
#    [[ $fC == '#' || $fC == '"' ]] && variable="" || true
#}
#resetVariablesIfComment () {
#    local -n var
#    for var in ${*}; do
#        echo "'${var}'"
#        [[ ${var:+IS_SET} ]] && resetVariableIfComment ${!var} || true
#    done
#}

# I should define these at the shell level
noOrEmptyFile () {
    [[ ! "${1:+IS_SET}" || ! -f "${1}" || ! -s "${1}" ]]
}
exitIfNoOrEmptyFile () {
    local label="file"
    local opt; OPTIND=1; while getopts l: opt; do case $opt in
        l) label="${OPTARG}" ;;
        *) >&2 echo "Unsupported option '$opt', ignoring"
    esac; done; shift $((OPTIND - 1))

    noOrEmptyFile "${1:-""}" && { printf >&2 "Missing or empty %s, exiting" "${label}"; exit 1; }
}

processVimPlugin () {
    local package="${1:-""}"
    local where="${2:-""}"
    local always="${3:-""}"
    local aOrO
    [[ ! $package ]] && { debug "Comment line or missing package, skipping"; true; return; }
    [[ $where ]] && where="-w ${where}"
    shopt -s nocasematch; case $always in
        opt*|"") aOrO="-o" ;;
        *)       aOrO="-a" ;;
    esac
    addOrUpdateVimPlug "${where}" ${aOrO} "$package"
}

# see note below where this is referenced in comment
## this should probably be a generic function....
#stripCommentsFromLine () {
#    local -n stripCommentsFromLine=$1
#
#    # strip any comments from the line; comments can begin with #
#    # (shell style) or " (vi/vim style); it doesn't matter which
#    # one we start with, just strip either comment marker and
#    # everything that follows it, first from the original line...
#
#    stripCommentsFromLine="${stripCommentsFromLine%%#*}"
#
#    # ...then strip the other comment marker, etc., from the
#    # stripped line, to make sure we handle both cases
#
#    stripCommentsFromLine="${stripCommentsFromLine%%\"*}"
#}

validatePlugCount () {
    local -i installCnt
    installCnt=$(addOrUpdateVimPlug -l | wc -l)
    local -i wantedCnt
    wantedCnt=$(grep -c -v -e '^ *#' -e '^ *$' "${manifest}")
    if [[ $installCnt -eq $wantedCnt ]]; then
        stdErr "Installation and wanted counts match."
        true
    else
        stdErr "Installed and wanted counts do not match, please validate"
        false
    fi
}

exitIfNoOrEmptyFile -l manifest "${manifest}"
[[ $doUpdate ]] && while read -r line; do
    # we cannot use this because older BASH, e.g., RHEL 7,
    # does not support variable references
    #stripCommentsFromLine line
    line="${line%%#*}"
    line="${line%%\"*}"
    # shellcheck disable=SC2086 # we want the line to be split
    processVimPlugin ${line}
done < "${manifest}"

declare -i rc=0
if [[ $doCount ]]; then
    validatePlugCount
    rc=$?
fi

exit $rc
